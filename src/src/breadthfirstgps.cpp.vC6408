#include <vector>
#include <queue>
#include <stack>
#include "breadthfirstgps.h"

std::stack<Cardinal8> BreadthFirstGPS::getPath(Cardinal8 **fromWhere, const Coordinate current, const Coordinate destination){
    std::stack<Cardinal8> path;
    Coordinate traversalCoord = destination;

    while(!(traversalCoord == current)){
      traversalCoord = maze->adjacentCell(traversalCoord.x, traversalCoord.y,
                                           fromWhere[traversalCoord.x][traversalCoord.y]);
      path.push(oppositeDirection(fromWhere[traversalCoord.x][traversalCoord.y]));
    }
    return path;
    /*path.push(North);
    return path;*/
}


/*void BreadthFirstGPS::setMaze(Maze* maze){
    this->maze = maze;
}*/

Cardinal8 BreadthFirstGPS::nextDirection(const Coordinate start,  const Coordinate destination){
    //Coordinate current;
    //Coordinate Destination;
    Coordinate current = start;
    std::queue<Coordinate> coordQueue;
    std::vector<Coordinate> neighbors;

    Cardinal8 **fromWhere = new Cardinal8*[maze->getSizeX()];
    for(int i=0; i<maze->getSizeY(); i++){
        fromWhere[i] = new Cardinal8[maze->getSizeX()];
    }
   while(!coordQueue.empty()){

     current = coordQueue.front();
     coordQueue.pop();
     if(current == destination){
           break;
    }

    //for(int i=0; i<maze->getNeighboringCells(current.x, current.y).size(); i++)
    //neighbors.push_back(maze->getNeighboringCells(current.x, current.y).at(i));
     neighbors = maze->getNeighboringCells(current.x, current.y);

    for(int i=0; i<neighbors.size(); i++){ //Maybe iterator?
         if(!maze->hasTraversalVisited(neighbors.at(i))){
            maze->setTraversalVisited(neighbors.at(i));

           //Keep track of where the robot has been

           fromWhere[neighbors.at(i).x][neighbors.at(i).y]
               = maze->getDirectionBetweenCells(current, neighbors.at(i)); //get which direction by asking the maze
              //Add neighbor to the queue
              coordQueue.push(neighbors.at(i));
           }
        }
       //neighbors.clear();
    }
   //Need to write path pseudo code that uses fromWhere
   std::stack<Cardinal8> path;
   path = this->getPath(fromWhere, start, destination);
   return path.top();
}


